#!/usr/bin/env python3
"""articulate-qqq (aq): AI thought expansion via ??? and !!! markers."""

import argparse
import subprocess
import sys
from pathlib import Path

# Add lib to path
_root = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(_root))

from lib import VERSION, Config
from lib.processor import process_file
from lib.watcher import watch, stop_watcher


def cmd_run(args, config: Config):
    """Process markers in a file once."""
    target = Path(args.target).resolve()
    if not target.exists():
        print(f"[aq] File not found: {target}")
        sys.exit(1)
    if not target.is_file():
        print(f"[aq] Not a file: {target}")
        sys.exit(1)

    count = process_file(target, config)
    if count == 0:
        print(f"[aq] No markers found in {target.name}")


def cmd_watch(args, config: Config):
    """Watch a file or directory for marker changes."""
    target = Path(args.target).resolve()
    if not target.exists():
        print(f"[aq] Path not found: {target}")
        sys.exit(1)

    watch(target, config)


def cmd_stop(args, config: Config):
    """Stop a running watcher."""
    stop_watcher()


def cmd_update(args, config: Config):
    """Update aq to the latest version via git pull."""
    repo_dir = _root
    git_dir = repo_dir / ".git"

    if not git_dir.exists():
        print(f"[aq] Not a git repo: {repo_dir}")
        print(f"[aq] Reinstall: curl -fsSL https://raw.githubusercontent.com/kangthink/articulate-qqq/main/install.sh | bash")
        sys.exit(1)

    print(f"[aq] Updating from {repo_dir}...")
    result = subprocess.run(
        ["git", "pull", "--ff-only"],
        cwd=repo_dir,
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"[aq] Update failed: {result.stderr.strip()}")
        sys.exit(1)

    output = result.stdout.strip()
    # git pull says "Already up to date" (en) or similar in other locales
    # If no files changed, it's up to date
    if "Already" in output or "already" in output or "업데이트" in output:
        print(f"[aq] Already up to date (v{VERSION})")
    else:
        print(output)
        print(f"[aq] Updated. Restart aq to use the new version.")


def main():
    parser = argparse.ArgumentParser(
        prog="aq",
        description="articulate-qqq: AI thought expansion via ??? and !!! markers",
    )
    parser.add_argument("--version", action="version", version=f"aq {VERSION}")

    # Global options
    parser.add_argument("--dry-run", action="store_true", help="Preview without modifying files")
    parser.add_argument("--lang", type=str, default=None, help="Force response language (ko, en, ...)")
    parser.add_argument("--prompt", type=str, default=None, help="Custom instruction to append")
    parser.add_argument("--poll-interval", type=float, default=1.0, help="Polling interval in seconds (default: 1)")
    parser.add_argument("--glob", type=str, default="*.md", help="File pattern for watch mode (default: *.md)")
    parser.add_argument("--timeout", type=int, default=120, help="Claude CLI timeout in seconds (default: 120)")
    parser.add_argument("--structure", action="store_true", help="Use structured 3-axis questions for ??? (default: free-form)")
    parser.add_argument("--model", type=str, default="claude", choices=["claude", "gemini", "codex"], help="AI provider (default: claude)")

    sub = parser.add_subparsers(dest="command")

    # run
    p_run = sub.add_parser("run", help="Process markers in a file once")
    p_run.add_argument("target", help="File to process")

    # watch
    p_watch = sub.add_parser("watch", help="Watch file/directory for changes")
    p_watch.add_argument("target", help="File or directory to watch")

    # stop
    sub.add_parser("stop", help="Stop the running watcher")

    # update
    sub.add_parser("update", help="Update aq to the latest version")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    config = Config(
        dry_run=args.dry_run,
        lang=args.lang,
        custom_prompt=args.prompt,
        poll_interval=args.poll_interval,
        glob_pattern=args.glob,
        timeout=args.timeout,
        structure=args.structure,
        model=args.model,
    )

    commands = {
        "run": cmd_run,
        "watch": cmd_watch,
        "stop": cmd_stop,
        "update": cmd_update,
    }

    commands[args.command](args, config)


if __name__ == "__main__":
    main()
